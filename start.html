async function startGraffitiAnimatie() {
    console.log('ðŸŽ¨ START');
    
    if (graffitiBezig) return;
    graffitiBezig = true;

    let index;
    do {
        index = Math.floor(Math.random() * GRAFFITI_SVGS.length);
    } while (index === vorigeSvgIndex && GRAFFITI_SVGS.length > 1);
    vorigeSvgIndex = index;

    const svgUrl = GRAFFITI_SVGS[index];
    const kleur = GRAFFITI_KLEUREN[Math.floor(Math.random() * GRAFFITI_KLEUREN.length)];

    try {
        const response = await fetch(svgUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        let svgText = await response.text();
        
        // NUCLEAR OPTION: Verwijder ALLE fills uit de raw SVG text
        svgText = svgText.replace(/fill="[^"]*"/gi, '');
        svgText = svgText.replace(/fill:[^;"]*;?/gi, '');
        svgText = svgText.replace(/style="[^"]*fill[^"]*"/gi, 'style=""');
        
        // Verwijder ook <style> tags
        svgText = svgText.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
        
        console.log('ðŸ“ SVG na cleanup (eerste 500 chars):');
        console.log(svgText.substring(0, 500));
        
        graffitiContainer.innerHTML = svgText;
        await new Promise(r => requestAnimationFrame(r));
        
        const svg = graffitiContainer.querySelector('svg');
        if (!svg) throw new Error('Geen SVG');
        
        // CONVERTEER MM NAAR PX
        const MM_TO_PX = 3.779527559;
        
        let widthMM, heightMM;
        
        const widthAttr = svg.getAttribute('width');
        const heightAttr = svg.getAttribute('height');
        
        if (widthAttr && widthAttr.includes('mm')) {
            widthMM = parseFloat(widthAttr);
            heightMM = parseFloat(heightAttr);
        } else {
            const viewBox = svg.getAttribute('viewBox');
            if (viewBox) {
                const parts = viewBox.split(/\s+|,/);
                widthMM = parseFloat(parts[2]);
                heightMM = parseFloat(parts[3]);
            } else {
                widthMM = 100;
                heightMM = 20;
            }
        }
        
        const widthPX = widthMM * MM_TO_PX;
        const heightPX = heightMM * MM_TO_PX;
        
        svg.setAttribute('viewBox', `0 0 ${widthPX} ${heightPX}`);
        svg.setAttribute('width', widthPX);
        svg.setAttribute('height', heightPX);
        
        await new Promise(r => requestAnimationFrame(r));
        
        // VIND ALLE PATHS EN FORCE GEEN FILL
        const alleElementen = svg.querySelectorAll('*');
        const paths = [];
        
        alleElementen.forEach((elem, idx) => {
            const tagName = elem.tagName.toLowerCase();
            
            // Verwijder ALLES wat niet drawing is
            if (!['path', 'line', 'polyline', 'polygon', 'g', 'svg'].includes(tagName)) {
                console.log(`ðŸ—‘ï¸ [${idx}] Verwijder:`, tagName);
                elem.remove();
                return;
            }
            
            // ULTRA FORCE geen fill
            elem.removeAttribute('fill');
            elem.removeAttribute('style');
            elem.style.cssText = 'fill: none !important;';
            
            if (['path', 'line', 'polyline', 'polygon'].includes(tagName)) {
                console.log(`ðŸ“ [${idx}] Path gevonden:`, elem.getAttribute('d')?.substring(0, 50));
                
                try {
                    const length = elem.getTotalLength();
                    if (length > 0) {
                        paths.push({ path: elem, length });
                        console.log(`  âœ“ Length:`, Math.round(length));
                    }
                } catch (e) {
                    console.warn(`  âœ— getTotalLength failed:`, e.message);
                }
            }
        });
        
        console.log('ðŸ›¤ï¸ Totaal animeerbare paths:', paths.length);
        
        if (paths.length === 0) throw new Error('GEEN PATHS!');
        
        // SCHAAL: 50% kleiner
        const maxWidth = window.innerWidth * 0.85;
        let schaal = Math.max(10, maxWidth / widthPX);
        schaal = schaal / 6;
        
        const nieuweWidth = widthPX * schaal;
        const nieuweHeight = heightPX * schaal;
        
        svg.style.width = nieuweWidth + 'px';
        svg.style.height = nieuweHeight + 'px';
        svg.style.display = 'block';
        
        console.log('ðŸ“ Finale grootte:', Math.round(nieuweWidth), 'x', Math.round(nieuweHeight), 'px');
        
        // POSITIONEER
        const knopRect = startBtn.getBoundingClientRect();
        const gifRect = document.querySelector('.gif-section').getBoundingClientRect();
        const beschikbareRuimte = gifRect.top - knopRect.bottom;
        const centerY = knopRect.bottom + (beschikbareRuimte * 0.50);
        
        graffitiY = centerY;
        graffitiHoogte = nieuweHeight * 1.5;
        
        graffitiContainer.style.top = (centerY - nieuweHeight / 2) + 'px';
        graffitiContainer.classList.add('actief');
        
        // ANIMEER
        let totalLength = paths.reduce((sum, p) => sum + p.length, 0);
        const schrijfDuur = 2000;
        let cumulativeLength = 0;
        let vorigePoint = null;
        
        paths.forEach(({ path, length }, idx) => {
            const startDelay = (cumulativeLength / totalLength) * schrijfDuur;
            const pathDuur = (length / totalLength) * schrijfDuur;
            cumulativeLength += length;
            
            setTimeout(() => {
                console.log(`ðŸŽ¬ [${idx}] Start animatie path`);
                
                // ZET STROKE
                path.setAttribute('stroke', kleur);
                path.setAttribute('stroke-width', '5');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none'); // NOGMAALS!
                path.style.cssText = `fill: none !important; stroke: ${kleur}; stroke-width: 5px;`;
                path.style.strokeDasharray = length;
                path.style.strokeDashoffset = length;
                
                const start = performance.now();
                
                function animate(now) {
                    const elapsed = now - start;
                    const t = Math.min(elapsed / pathDuur, 1);
                    
                    path.style.strokeDashoffset = length * (1 - t);
                    
                    // Spray
                    if (Math.random() < 0.5 && t < 0.95) {
                        try {
                            const point = path.getPointAtLength(length * t);
                            const containerRect = graffitiContainer.getBoundingClientRect();
                            
                            let angle = 0;
                            if (vorigePoint) {
                                const dx = point.x - vorigePoint.x;
                                const dy = point.y - vorigePoint.y;
                                angle = Math.atan2(dy, dx);
                            }
                            
                            for (let i = 0; i < 2; i++) {
                                maakSprayStreak(
                                    point.x + containerRect.left,
                                    point.y + containerRect.top,
                                    kleur,
                                    angle
                                );
                            }
                            
                            vorigePoint = point;
                        } catch (e) {}
                    }
                    
                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else if (idx === paths.length - 1) {
                        console.log('âœ… Alle animaties klaar');
                        const staanTijd = 3000 + Math.random() * 2000;
                        setTimeout(veegGraffitiWeg, staanTijd);
                    }
                }
                requestAnimationFrame(animate);
            }, startDelay);
        });
        
    } catch (error) {
        console.error('âŒ FOUT:', error.message);
        graffitiBezig = false;
        wachtEnSprayGraffiti();
    }
}
